[
  {
    "objectID": "implement/overview.html",
    "href": "implement/overview.html",
    "title": "Development Tools",
    "section": "",
    "text": "There are many useful Python development tools, and we do not pretend to know them all. This section of the site offers guidance on which tools to use to get started and is based purely on our present abilities to provide guidance rather than any claims of one tool being better than any other. The tools identified and summarized here are selected based on current usage and willingness of a team member to share their knowledge here. If you like a tool that is not included in this section, please contribute content to improve the coverage here."
  },
  {
    "objectID": "implement/overview.html#integrated-development-environments",
    "href": "implement/overview.html#integrated-development-environments",
    "title": "Development Tools",
    "section": "Integrated Development Environments",
    "text": "Integrated Development Environments\nIntegrated Development Environments (IDEs) are the workhorse for efficient software development, whether doing simple scripting or developing complex machine learning systems. The recommended IDE for Python development at present is VS Code, in the sense that current contributors to this content use VS Code and have more knowledge to share about VS Code than other IDEs such as, for example, PyCharm or Spyder. Read on…"
  },
  {
    "objectID": "implement/overview.html#package-and-environment-managemers",
    "href": "implement/overview.html#package-and-environment-managemers",
    "title": "Development Tools",
    "section": "Package and Environment Managemers",
    "text": "Package and Environment Managemers\nPython packages are distributed by a wide number of individuals and organizations, with just-as-widely varying degrees of sophistication. Package and environment managers (PEMs) are tools that seek to help users of these Python packages resolve the inevitable web of dependencies that emerge between various packages (dependency hell). Read on…"
  },
  {
    "objectID": "implement/overview.html#version-control-systems",
    "href": "implement/overview.html#version-control-systems",
    "title": "Development Tools",
    "section": "Version Control Systems",
    "text": "Version Control Systems\nA Version Control System (VCS) is a database system for tracking changes to a filesystem over time. There are many types of VCSs that have been developed over the years. There is an “interesting” history of version control available from Git for those interested in exploring the weeds of yesteryear. For others, it’s probably sufficient to point to the currently available systems and provide a brief summary of each. Read on…"
  },
  {
    "objectID": "implement/overview.html#documentation",
    "href": "implement/overview.html#documentation",
    "title": "Development Tools",
    "section": "Documentation",
    "text": "Documentation\nDocumentation is a vital part of any Python project. See the documentation tools page for a review of using some recommended tools for documenting your projects."
  },
  {
    "objectID": "implement/overview.html#containerization",
    "href": "implement/overview.html#containerization",
    "title": "Development Tools",
    "section": "Containerization",
    "text": "Containerization\nPackage and environment management is necessary but insufficient to ensure reproducible projects. Environments run on operating systems, which run on real or virtual machines. Containerization is a technology developed to support reproducibility and virtualization (at scale) of operating systems. Read on…"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python Starter Template",
    "section": "",
    "text": "This repo provides a basic starter template for best practices developing and testing unpackaged Python code. Emphasis on that last point - this is not a Python packaging template. This template is for use with generic Python projects that want to take advantage of automated tools to improve the development process, including:\n\nVirtual environment management with venv\nAutomated code review with Pylint and Black\nFunctional tests with Pytest\nRemote tests to support reproducibility (via GitHub Actions)\nAutomated project documentation rendering with Quarto\n\n\n\n\n\n\n\nNote\n\n\n\nMany of the concepts implemented here are directly from the excellent Duke University Coursera Course by Noah Gift: Cloud Computing Foundations"
  },
  {
    "objectID": "index.html#create-a-new-repo-from-this-template",
    "href": "index.html#create-a-new-repo-from-this-template",
    "title": "Python Starter Template",
    "section": "Create a new repo from this template",
    "text": "Create a new repo from this template\nIf you would like to simply use this repo as a template for starting a new project (in contrast to contributing to this template to improve it), take the following steps:\n\nTo start a new GitHub repo from this template, at the top of this repo’s home page select the “Use this template” option.\n\n\n\n\nClick the green button\n\n\n\nSpecify an organization and a name for your new project, and then create the repo. If you are creating the new repo in your personal GitHub account, select Public if you want to make use of GitHub Pages for your project (private Pages are only available on BC org repos). On the new repo’s page, copy the cloning address from the “Code” dropdown menu (indicated below as &lt;repo-url&gt;). Use HTTPS or SSH depending on your local setup for Git. If you have never used Git and need further instructions, see the Git Primer tutorial before continuing.\nOn your machine, open a Bash (or other) terminal in a directory of your preference and execute the command git clone &lt;repo-url&gt; &lt;local-directory-name&gt;. Replace &lt;repo-url&gt; with the URL copied from the repo to clone it, and replace &lt;local-directory-name&gt; with whatever you’d like to name the folder on your machine.\n\n\n\n\n\n\n\nNote\n\n\n\nIf you running git clone ... from a folder you’ve already created that you’d like to clone into, just use . as the &lt;local-directory-name&gt;\n\n\nThe remainder of these basic usage instructions assume that all suggested actions are taken from this new repository."
  },
  {
    "objectID": "index.html#update-repo-settings-for-github-pages",
    "href": "index.html#update-repo-settings-for-github-pages",
    "title": "Python Starter Template",
    "section": "Update repo settings for GitHub Pages",
    "text": "Update repo settings for GitHub Pages\nIf you’d like to use the GitHub Pages template for your project, you need to make a few changes in your repo settings:\n\nNavigate to the repo-level settings, and on the left nav panel, select “Pages”.\nUnder “Build and Deployment”, click the “Source” dropdown and select “GitHub Actions”. This setting enables use of the GitHub Workflow to publish the project Page using GitHub Actions.\n\n… Instructions in progress…"
  },
  {
    "objectID": "index.html#create-virtual-environment",
    "href": "index.html#create-virtual-environment",
    "title": "Python Starter Template",
    "section": "Create virtual environment",
    "text": "Create virtual environment\nThe next step is to build the virtual environment for this project locally, as follows:\n\nFirst, note that the project “requires” (by way of declaration right here), use of Python 3.12; since venv uses whatever Python interpreter calls it as the base, each user needs to be sure to call venv with Python 3.12 as the active interpreter. To do so:\n\nInstall Python 3.12 from python.org\nKeep all defaults when running the installer, noting the installation location should be at C:\\Users\\&lt;user&gt;\\AppData\\Local\\Programs\\Python\\Python312\nClose the installer app when it is finished\nOpen a Bash (or Powershell) terminal\nEnter command C:\\Users\\&lt;user&gt;\\AppData\\Local\\Programs\\Python\\Python312\\python -m venv .venv to create a virtual environment in a subdirectory named .venv\n\nRunning the python -m venv command from the directory where Python 3.12 is stored forces use of the 3.12 interpreter as base\nCreating the virtual environment in the .venv directory follows standard practice and ensures that these files are ignored by git (as indicated in the .gitignore file in the “Environments” section)\n\nOpen the .venv folder and then the pyvenv.cfg file; note that the Python version is 3.12.x\n\nNext, add the required packages to this virtual environment:\n\nFirst, activate the environment by running\n\n(PowerShell) .venv/Scripts/Activate.ps1\n(Bash) .venv/Scripts/activate\n\nInstall requirements with pip install -r requirements.txt"
  },
  {
    "objectID": "index.html#automatic-linting-and-formatting-with-pylint-and-black",
    "href": "index.html#automatic-linting-and-formatting-with-pylint-and-black",
    "title": "Python Starter Template",
    "section": "Automatic linting and formatting with Pylint and black",
    "text": "Automatic linting and formatting with Pylint and black\nIt is important but tedious to follow formatting standards. Automated tools have been developed by those who agree with this statement (starting at Bell Labs almost 50 years ago). A linter is a tool for static code analysis used to flag programming errors, bugs, stylistic errors and suspicious constructs. Pylint is one such tool that is widely used for Python to enforce the PEP8 Style Guide. Black is another, and these two tools are often used in parallel to get the most benefit. The following steps will help you understand how to use these tools to improve your Python projects:\n\nUse Pylint to analyze the code in the src folder:\npylint src\nThis command will analyze all *.py files in the src folder. Note that the output to the terminal includes recommendations to include docstrings for modules and functions, and another recommendation to improve efficiency of the python_version function in version.py.\nNone of these recommendations are compliance issues, and they can be suppressed. Note the overall score is 4.62/10. Suppressing these recommendations with the --disable flag:\npylint --disable=R,C src\n\nNote, --disable=R,C indicates that ‘refactor’ and ‘convention’ messages should be disabled The resulting output should now have no suggestions, and the overall rating is 10/10\n\nFinally, only errors can be reported by passing the --errors-only flag\npylint --errors-only src\nNote the rating is no longer returned. Try introducing an error into a module and run again to see what happens.\nNow use black to autoformat your Python code to PEP8 compliance. Black is “an opinionated strict subset of PEP8”. While Pylint can be used to generate a set of recommendations or flag errors, Black can be used to automatically enforce formatting conventions:\n\nFirst, open hello.py and paste the following function into the end of the module:\ndef my_func(x):\n    \"\"\"\n    This is my function it returns the product of `x` and `a`\n    \"\"\"\n    a = [\n        1,2,3\n    ]\n    return a*x\nNow run the command black src, and open hello.py again. Note the input has been reformatted to:\ndef my_func(x):\n    \"\"\"\n    This is my function it returns the product of `x` and `a`\n    \"\"\"\n    a = [1, 2, 3]\n    return a * x\n\n\nBy using first Black and then Pylint in succession, much of the tedium of code review can be avoided and errors can be caught and corrected before committing."
  },
  {
    "objectID": "index.html#unit-tests-with-pytest",
    "href": "index.html#unit-tests-with-pytest",
    "title": "Python Starter Template",
    "section": "Unit tests with Pytest",
    "text": "Unit tests with Pytest\nAfter static review, the code can be dynamically tested. The Pytest package is designed to facilitate testing of Python projects from basic unit tests to full evaluation of functional requirements for complex projects. Here it is used to enable and demonstrate basic unit testing.\n\nRun the test suite in the tests directory with the command python -m pytest -vv tests.\nNote the results (percent complete and pass/fail status) printed to the terminal after each functional unit test."
  },
  {
    "objectID": "index.html#remote-testing",
    "href": "index.html#remote-testing",
    "title": "Python Starter Template",
    "section": "Remote testing",
    "text": "Remote testing\nTesting on the development system is a fundamental first step, but Python projects should also be regularly tested on remote systems to ensure that they can be reproduced “from scratch” without issue. The GitHub Workflow file checks.yml enables an automated workflow to run the above steps (build Python environment, format and lint code, run tests) on a remote GitHub “runner”. To learn more about authoring and editing workflows in GitHub, visit the GitHub Workflows tutorial."
  },
  {
    "objectID": "index.html#trunk-based-development-branch-protections-and-continuous-integration",
    "href": "index.html#trunk-based-development-branch-protections-and-continuous-integration",
    "title": "Python Starter Template",
    "section": "Trunk-based Development, Branch Protections and Continuous Integration",
    "text": "Trunk-based Development, Branch Protections and Continuous Integration\nTrunk-based development is a development practice meant to support change management. As a project’s codebase changes over time, it is important to control the scope of any single set of changes, so that they can be thoroughly tested before merging and so that they can be rolled back in the event of unforeseen consequences. The concept is relatively simple:\n\nThe main branch of a repo represents “production-ready” code, i.e., the best currently available implementation of the project’s goals\nAny new feature (a new function, a better version of a function, etc) is implemented in a feature branch, which begins as an exact copy of the current state of the main branch\nWhen a new feature is developed, it is tested and then merged via Pull Request. A Pull Request (PR) is a request from one branch (feature branch) to another branch (main) requesting that main pull the changes from the feature branch and commit them. Using PRs that are generated after fully testing the new feature is the standard way of preventing any untested changes from polluting the production/main branch (aside - the ‘production’ branch need not always be named main: for instance, several branches may host production versions of code serving different project requirements - e.g., a “baseline” version may be served from main while other scenarios are served from scenario_n branches).\n\nBranch protections are a set of configuration options that can be specified in GitHub for each branch of the repository. This feature enables best practices like preventing changes to the repo’s main branch except by an approved Pull Request originating from another branch, which helps prevent untested changes from creeping into your production code. When working on projects with more than a few trusted collaborators, it becomes very important to implement branch protections and continuous integration practices."
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "Python Starter Template",
    "section": "Documentation",
    "text": "Documentation\nAnother critical component of any well-developed Python project is, of course, documentation. For this template, the documentation is written/edited in the docs directory (by humans) and is then automatically rendered into a website stored in the build-docs folder during the fully automated build process. More details on this procedure are included in the documentation tools page."
  },
  {
    "objectID": "design/overview.html",
    "href": "design/overview.html",
    "title": "Design Overview",
    "section": "",
    "text": "This project aims to provide a minimum working example for an Azure web app (using Dash) that runs SWMM in the backend based on a constrained set of user inputs at the front end, logs run info to an MLFlow tracking URI in an Azure ML workspace, and displays select outputs to the Dash layout."
  },
  {
    "objectID": "design/overview.html#virtual-environment",
    "href": "design/overview.html#virtual-environment",
    "title": "Design Overview",
    "section": "Virtual environment",
    "text": "Virtual environment\nThe virtual environment is specified via the requirements.txt file at the project root. Requirements include:\n# python=3.11\npip\npandas\nmatplotlib\nmlflow\nplotly\ndash\npyswmm[swmm5.2.3]\nswmmio\n\nThe essential pip, pandas and matplotlib libraries should need no explanation.\nThe mlflow library provides model lifecycle management and run info tracking capabilities.\nThe plotly and dash libraries provide the core visualization support.\nThe pyswmm and swmmio libraries enable Python-based interaction with OWA SWMM. The pip extras syntax pyswmm[swmm5.2.3] indicates that a platform-appropriate version of OWA SWMM v5.2.3 will be installed alongside the pyswmm library."
  },
  {
    "objectID": "design/overview.html#integrations",
    "href": "design/overview.html#integrations",
    "title": "Design Overview",
    "section": "Integrations",
    "text": "Integrations\nThe integration between Azure web apps and GitHub is a built-in feature of Azure web app services, so the design is trivial and details provided in the implementation section should suffice to support reproducibility. The integration between Azure ML workspaces and MLflow is also a built in feature to Azure ML Studio, so details are deferred to implementation.\nThe tricky/novel (to me) part to this design is the integration between an Azure web app and an Azure ML workspace such that the data input to the app by users can be fully tracked through to the MLflow registry within the Azure ML workspace."
  },
  {
    "objectID": "use/overview.html",
    "href": "use/overview.html",
    "title": "Getting Started with VS Code",
    "section": "",
    "text": "This page is intended as primer/SOP for installing and configuring VS Code for a generic Python project.\nThe primary steps covered here are:"
  },
  {
    "objectID": "use/overview.html#install-vs-code",
    "href": "use/overview.html#install-vs-code",
    "title": "Getting Started with VS Code",
    "section": "Install VS Code",
    "text": "Install VS Code\nVS Code can be installed simply from the product’s main download page. Simply select the operating system for your machine and run the installer: - Accept the license agreement; - Accept default options for install destination; - Accept default Start Menu location; - Under “Select Additional Tasks”, keep the default selections and also select the two options to add “Open with Code” actions to Windows Explorer menus (this will make life easier), and (optionally) create a desktop icon;"
  },
  {
    "objectID": "use/overview.html#install-extensions",
    "href": "use/overview.html#install-extensions",
    "title": "Getting Started with VS Code",
    "section": "Install Extensions",
    "text": "Install Extensions\nOnce VS Code is installed on your machine, open it and navigate on the left menu bar to the Extensions blade (it looks like a Tetris game), or use the keyboard shortcut (Ctrl+Shift+X) instead. Use the search bar to find the desired extensions:\n\nPython - This extension (make sure to select the extension from Microsoft, not others) includes Intellisense (autocompletion, syntax checking), tools for linting (Pylint, Flake8), debugging, code formatting (black, autopep), refactoring, integrated unit tests (unittest, pytest) and more. Join 100M other users taking advantage of these features."
  },
  {
    "objectID": "use/overview.html#basic-usage",
    "href": "use/overview.html#basic-usage",
    "title": "Getting Started with VS Code",
    "section": "Basic Usage",
    "text": "Basic Usage\nIn this section we’ll walk through some basic usage steps, setting up some additional features along the way.\n\nOnce VS Code is installed, use the Accounts icon at the bottom left of the window to log in to your GitHub account through VS Code, following any multi-factor authentication steps indicated.\nClone the Python project starter template repo from GitHub:\n\nUse the Ctrl+Shift+P shortcut to activate the command pallette (use Esc to exit it as needed)\nSearch the pallette for ‘Terminal’ and select the Terminal: Create New Terminal option that appears\nNote that the terminal “opens” as a vertical split in the VS Code window - it is always accessible (or minimizable) by sliding this vertical separator up or down as desired\ncd and/or mkdir to a desired directory\nEnter the command git clone git@github.com:gcoyle83/quarto-example-site.git, and enter authentication information as required (add SSH keygen instructions)\n\nWhen you open a VS Code window directly from a folder, the root of the project Explorer is at that folder; it is often helpful when working on multiple projects to open separate VS Code windows for each project, using the “Open with VS Code” action accessible from the right-click context menu in Windows Explorer.\n\nNavigate to the repo location in Windows Explorer\nRight click on the repo directory\nSelect “Open with Code”, and note the root directory\nIn VS Code, select the source control blade (or use the strange Ctrl+Shift+G followed with g shortcut)\nExpand the Branches section of the blade and note that one branch (main) is shown\nExpand the Remotes section of the blade and then expand the origin to show all available branches\nHover over the website branch and note the several icons that appear on the right side\nHover over the first of these icons and note that it says “Switch to branch” - this is the same as the git switch command, but it also fetches it if it’s not currently in the local\nSelect the switch icon to switch to the website branch; enter a local branch name or use the remote name to track locally (just press enter)\nObserve that the branch is added to the Branches blade, and has a check-mark next to it\nHover over the check-mark; observe that the popup information is the same as would be returned by git status on the command line\nReturn to the Explorer blade (Ctrl+Shift+E), and note that the files shown now reflect the Quarto website content\nOpen the about.qmd file, and add your name to the list in the Development Group Members section of the page, then save your changes (Ctrl+S)\nReturn to the source control blade (Ctrl+Shift+G + g)\nExpand the source control section, and note that there is a change pending\nHover over the “Changes” list, and then over each of the three resulting icons - they are stash, discard and stage command buttons - note also that the individual files are listed with similar buttons to revert or stage changes file-by-file; use the “Stage All Changes” button to stage your changes\nType a useful commit message and press the green Commit button\nClick the green Sync Changes button to sync with the remote GitHub repo"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "The Python Development Group is an informal team of associates from various practices that make regular use of Python to improve and/or accelerate their workflows. Recognizing that we all face similar issues in selecting and learning about various “pieces” of the Python development process, we elected to work together toward pooling our collective experience through regular (monthly) discussion of best practices and generation of documentation around what works (or notably doesn’t work) well for Python projects.\n\nDevelopment Group Members\nThe Python Dev Group members are voluntary and unofficial. If you are interested in joining the group to participate in these discussions, please reach out to a current team member and let them know.\n\nGreg Coyle\n\n\n\n\n\n Back to top"
  }
]